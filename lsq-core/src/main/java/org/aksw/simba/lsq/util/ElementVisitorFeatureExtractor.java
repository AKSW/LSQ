package org.aksw.simba.lsq.util;

import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import org.aksw.jena_sparql_api.utils.ExprUtils;
import org.aksw.simba.lsq.vocab.LSQ;
import org.apache.jena.graph.Triple;
import org.apache.jena.query.Query;
import org.apache.jena.rdf.model.Resource;
import org.apache.jena.rdf.model.ResourceFactory;
import org.apache.jena.sparql.core.BasicPattern;
import org.apache.jena.sparql.core.PathBlock;
import org.apache.jena.sparql.core.TriplePath;
import org.apache.jena.sparql.expr.Expr;
import org.apache.jena.sparql.expr.ExprAggregator;
import org.apache.jena.sparql.path.Path;
import org.apache.jena.sparql.syntax.Element;
import org.apache.jena.sparql.syntax.ElementAssign;
import org.apache.jena.sparql.syntax.ElementBind;
import org.apache.jena.sparql.syntax.ElementData;
import org.apache.jena.sparql.syntax.ElementDataset;
import org.apache.jena.sparql.syntax.ElementExists;
import org.apache.jena.sparql.syntax.ElementFilter;
import org.apache.jena.sparql.syntax.ElementGroup;
import org.apache.jena.sparql.syntax.ElementMinus;
import org.apache.jena.sparql.syntax.ElementNamedGraph;
import org.apache.jena.sparql.syntax.ElementNotExists;
import org.apache.jena.sparql.syntax.ElementOptional;
import org.apache.jena.sparql.syntax.ElementPathBlock;
import org.apache.jena.sparql.syntax.ElementService;
import org.apache.jena.sparql.syntax.ElementSubQuery;
import org.apache.jena.sparql.syntax.ElementTriplesBlock;
import org.apache.jena.sparql.syntax.ElementUnion;
import org.apache.jena.sparql.syntax.ElementVisitor;
import org.apache.jena.sparql.syntax.ElementWalker;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Class to extract a set of features (expressed in SPIN terms) from a
 * SPARQL element
 *
 * @author raven
 *
 */
public class ElementVisitorFeatureExtractor
    implements ElementVisitor
{
    private static final Logger logger = LoggerFactory.getLogger(ElementVisitorFeatureExtractor.class);

    protected Set<Resource> features = new HashSet<Resource>();

    // Note: A query without triples and only with a values clause is perfectly fine and could be
    // generated by certain caching systems - hence it makes sense to track even this basic feature.
    public static void emit(Set<Resource> outFeatures, BasicPattern bgp) {
        // TODO We could emit a triple indicating the presence of a BasicPattern
        // but because they should not be empty anyway, its sufficient to only
        // indicate only the presence of triple patterns
        //outFeatures.add(LSQ.BasicPattern);
        if(!bgp.isEmpty()) {
            outFeatures.add(LSQ.TriplePattern);
        }
    }

    @Override
    public void visit(ElementTriplesBlock el) {
        emit(features, el.getPattern());
    }

    @Override
    public void visit(ElementAssign el) {
        features.add(LSQ.Assign);
    }

    @Override
    public void visit(ElementGroup el) {
        features.add(LSQ.Group);
    }

    @Override
    public void visit(ElementDataset el) {
        features.add(LSQ.Dataset);
    }

    @Override
    public void visit(ElementData el) {
        features.add(LSQ.Values);
    }

    @Override
    public void visit(ElementUnion el) {
        features.add(LSQ.Union);
    }

    @Override
    public void visit(ElementOptional el) {
        features.add(LSQ.Optional);
    }

    @Override
    public void visit(ElementFilter el) {
        features.add(LSQ.Filter);

        Expr baseExpr = el.getExpr();
        List<Expr> exprs = ExprUtils.linearizePrefix(baseExpr, Collections.emptySet()).collect(Collectors.toList());

        for(Expr expr : exprs) {
            features.add(LSQ.Functions);

            if(expr.isFunction()) {
                // TODO Will use full URIs for custom sparql functions - may want to shorten them with prefixes
                String fnName = ExprUtils.getFunctionId(expr.getFunction());

                Resource fnRes = ResourceFactory.createResource(LSQ.ns + "fn-" + fnName);
                features.add(fnRes);
            }
        }
    }

    @Override
    public void visit(ElementBind el) {
        features.add(LSQ.Bind);
    }

    @Override
    public void visit(ElementService el) {
        features.add(LSQ.Service);
    }

    @Override
    public void visit(ElementExists el) {
        features.add(LSQ.Exists);
    }

    @Override
    public void visit(ElementNotExists el) {
        features.add(LSQ.NotExists);
    }

    @Override
    public void visit(ElementMinus el) {
        features.add(LSQ.Minus);
    }

    @Override
    public void visit(ElementNamedGraph el) {
        features.add(LSQ.NamedGraph);
    }

    /**
     * Note: Paths
     *
     */
    @Override
    public void visit(ElementPathBlock el) {
        PathBlock pathBlock = el.getPattern();
        for(TriplePath item : pathBlock.getList()) {
            Triple t = item.asTriple();
            if(t != null) {
                // Do not expose a path that can be expressed as a triple (pattern) as a TriplePath
                features.add(LSQ.TriplePattern);
            } else {
                features.add(LSQ.TriplePath);
                Path path = item.getPath();

                Set<Resource> pathFeatures = PathVisitorFeatureExtractor.getFeatures(path);
                features.addAll(pathFeatures);
            }
        }


        // Old code ; subject to removal
//        Op op = PathLib.pathToTriples(el.getPattern());
//        if(op instanceof OpBGP) {
//            emit(features, ((OpBGP) op).getPattern());
//        } else if (op instanceof OpPath) {
//            OpPath opPath = (OpPath)op;
//            Path path = opPath.getTriplePath().getPath();
//
//            features.add(LSQ.TriplePath);
//
//            Set<Resource> pathFeatures = PathVisitorFeatureExtractor.getFeatures(path);
//            features.addAll(pathFeatures);
//
//
//        } else {
//            throw new RuntimeException("Unsupported algebra expression: " + op);
//        }
    }

    @Override
    public void visit(ElementSubQuery el) {
        features.add(LSQ.SubQuery);

        Element subEl = el.getQuery().getQueryPattern();

        ElementWalker.walk(subEl, this);
    }


    public Set<Resource> getFeatures() {
        return this.features;
    }

    public static Set<Resource> getFeatures(Query query) {
        Set<Resource> result = new HashSet<>();

        Set<Resource> elFeatures = getFeatures(query.getQueryPattern());
        result.addAll(elFeatures);

        switch(query.getQueryType()) {
        case Query.QueryTypeSelect: result.add(LSQ.Select); break;
        case Query.QueryTypeConstruct: result.add(LSQ.Construct); break;
        case Query.QueryTypeDescribe: result.add(LSQ.Describe); break;
        case Query.QueryTypeAsk: result.add(LSQ.Ask); break;
        default: result.add(LSQ.Unknown); break;
        }

        if(query.isDistinct()) {
            result.add(LSQ.Distinct);
        }

        if(query.isReduced()) {
            result.add(LSQ.Reduced);
        }

        if(query.hasOrderBy()) {
            result.add(LSQ.OrderBy);
        }

        if(query.hasGroupBy()) {
            result.add(LSQ.GroupBy);
        }

        if(query.getLimit() != query.NOLIMIT) {
            result.add(LSQ.Limit);
        }

        if(query.getOffset() != query.NOLIMIT && query.getOffset() != 0) {
            result.add(LSQ.Offset);
        }

        if(query.hasAggregators()) {
            result.add(LSQ.Aggregators);


            List<ExprAggregator> aggs = query.getAggregators();
            for(ExprAggregator agg : aggs) {
                Resource fnRes = ResourceFactory.createResource(LSQ.ns + "agg-" + agg.getAggregator().getName().toLowerCase());
                result.add(fnRes);
            }

        }


        return result;
    }

    public static Set<Resource> getFeatures(Element element) {
        Set<Resource> result;

        if(element != null)
        {
            ElementVisitorFeatureExtractor visitor = new ElementVisitorFeatureExtractor();
            ElementWalker.walk(element, visitor);
            result = visitor.getFeatures();
        } else {
            result = Collections.emptySet();
        }
        return result;
    }
}
